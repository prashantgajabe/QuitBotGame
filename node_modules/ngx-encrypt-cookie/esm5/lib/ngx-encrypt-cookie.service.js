/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-encrypt-cookie.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Inject, PLATFORM_ID, InjectionToken } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import * as CryptoJS from 'crypto-js';
import * as i0 from "@angular/core";
var NgxEncryptCookieService = /** @class */ (function () {
    function NgxEncryptCookieService(platformId) {
        this.platformId = platformId;
        this.documentIsAccessible = isPlatformBrowser(this.platformId);
    }
    /**
     * @param keySize Cookie name
     * @param passPhrase secret passPhrase
     * @returns returns key when setting cookie and getting cookie
     * default keySize is 128/32 and default passPhrase is "Secret PassPhrase"
     */
    /**
     * @param {?=} keySize Cookie name
     * @param {?=} passPhrase secret passPhrase
     * @return {?} returns key when setting cookie and getting cookie
     * default keySize is 128/32 and default passPhrase is "Secret PassPhrase"
     */
    NgxEncryptCookieService.prototype.generateKey = /**
     * @param {?=} keySize Cookie name
     * @param {?=} passPhrase secret passPhrase
     * @return {?} returns key when setting cookie and getting cookie
     * default keySize is 128/32 and default passPhrase is "Secret PassPhrase"
     */
    function (keySize, passPhrase) {
        /** @type {?} */
        var salt = CryptoJS.lib.WordArray.random(128 / 8);
        /** @type {?} */
        var keySizeBytes;
        /** @type {?} */
        var secrtePassPhrase;
        keySize ? keySizeBytes = keySize : keySizeBytes = "128/32";
        passPhrase ? secrtePassPhrase = passPhrase : secrtePassPhrase = "Secret PassPhrase";
        switch (keySizeBytes) {
            case "128/32":
                /** @type {?} */
                var msg = CryptoJS.PBKDF2(secrtePassPhrase, salt, { keySize: 128 / 32 });
                return msg.toString();
                break;
            case "256/32":
                /** @type {?} */
                var msg = CryptoJS.PBKDF2(secrtePassPhrase, salt, { keySize: 256 / 32 });
                return msg.toString();
                break;
            case "512/32":
                /** @type {?} */
                var msg = CryptoJS.PBKDF2(secrtePassPhrase, salt, { keySize: 512 / 32 });
                return msg.toString();
                break;
        }
    };
    /**
     * encrypt() is calling when set() calls
     * @param val value to store in cookies
     * @param secret_key is a key generated by using generateKey() or user defined key.
     * @returns encrypted val to set() and there the cookie will set. if user doesnt generateKey or pass key error will be thrown.
    */
    /**
     * encrypt() is calling when set() calls
     * @private
     * @param {?} val value to store in cookies
     * @param {?} secret_key is a key generated by using generateKey() or user defined key.
     * @return {?} encrypted val to set() and there the cookie will set. if user doesnt generateKey or pass key error will be thrown.
     */
    NgxEncryptCookieService.prototype.encrypt = /**
     * encrypt() is calling when set() calls
     * @private
     * @param {?} val value to store in cookies
     * @param {?} secret_key is a key generated by using generateKey() or user defined key.
     * @return {?} encrypted val to set() and there the cookie will set. if user doesnt generateKey or pass key error will be thrown.
     */
    function (val, secret_key) {
        if (secret_key != null || secret_key != "" || secret_key.length > 0) {
            /** @type {?} */
            var encrypt_msg = CryptoJS.AES.encrypt(val, secret_key);
            return encrypt_msg;
        }
        else {
            console.error("Pass Secret key to set cookie");
        }
    };
    /**
     *
     * @param cookie_name cookie name which is stored
     * @param encrypted boolean - cookie stored having encrypted val or not
     * @param secret_key is key which is used to encrypt cookie val. it is not required if encrypted is false
     */
    /**
     *
     * @private
     * @param {?} cookieName
     * @param {?} encrypted boolean - cookie stored having encrypted val or not
     * @param {?=} secret_key is key which is used to encrypt cookie val. it is not required if encrypted is false
     * @return {?}
     */
    NgxEncryptCookieService.prototype.decrypt = /**
     *
     * @private
     * @param {?} cookieName
     * @param {?} encrypted boolean - cookie stored having encrypted val or not
     * @param {?=} secret_key is key which is used to encrypt cookie val. it is not required if encrypted is false
     * @return {?}
     */
    function (cookieName, encrypted, secret_key) {
        if (this.documentIsAccessible && this.check(cookieName)) {
            cookieName = encodeURIComponent(cookieName);
            /** @type {?} */
            var regExp = this.getCookieRegExp(cookieName);
            /** @type {?} */
            var result = regExp.exec(document.cookie);
            if (encrypted) {
                if (secret_key) {
                    /** @type {?} */
                    var encrypt_msg = this.safeDecodeURIComponent(result[1]);
                    /** @type {?} */
                    var decrypt_msg = CryptoJS.AES.decrypt(encrypt_msg, secret_key);
                    /** @type {?} */
                    var message = decrypt_msg.toString(CryptoJS.enc.Utf8);
                    return message;
                }
                else {
                    console.error("pass secret key to get cookie value");
                }
            }
            else {
                return this.safeDecodeURIComponent(result[1]);
            }
        }
        else {
            return '';
        }
    };
    /**
     * @param cookieName Cookie name
     * @returns boolean  whether cookie with specified name is existed or not
     */
    /**
     * @param {?} cookieName Cookie name
     * @return {?} boolean  whether cookie with specified name is existed or not
     */
    NgxEncryptCookieService.prototype.check = /**
     * @param {?} cookieName Cookie name
     * @return {?} boolean  whether cookie with specified name is existed or not
     */
    function (cookieName) {
        if (!this.documentIsAccessible) {
            return false;
        }
        /** @type {?} */
        var name = encodeURIComponent(cookieName);
        /** @type {?} */
        var regExp = this.getCookieRegExp(name);
        /** @type {?} */
        var exists = regExp.test(document.cookie);
        return exists;
    };
    /**
     *
     * @param cookieName cookie name
     * @param encryption boolean - whether to want encrypted or decrypted value.
     * @param key - it should enter if encrypted=true otherwise error will be thrown.key can be either generated using generateKey() or
                     user definded key
     */
    /**
     *
     * @param {?} cookieName cookie name
     * @param {?} encryption boolean - whether to want encrypted or decrypted value.
     * @param {?=} key - it should enter if encrypted=true otherwise error will be thrown.key can be either generated using generateKey() or
     * user definded key
     * @return {?}
     */
    NgxEncryptCookieService.prototype.get = /**
     *
     * @param {?} cookieName cookie name
     * @param {?} encryption boolean - whether to want encrypted or decrypted value.
     * @param {?=} key - it should enter if encrypted=true otherwise error will be thrown.key can be either generated using generateKey() or
     * user definded key
     * @return {?}
     */
    function (cookieName, encryption, key) {
        /** @type {?} */
        var val;
        if (encryption) {
            if (key) {
                val = this.decrypt(cookieName, encryption, key);
                return val;
            }
        }
        // if key is not passed or encrypted = false;
        val = this.decrypt(cookieName, false, null);
        return val;
    };
    /**
     * @param encrypted boolean - to know encrypted values are there
     * @param key  generatedKey() or user defined key - to decrypt encrypted values
     * @returns cookies - all the cookies  stored
     */
    /**
     * @param {?=} encrypted boolean - to know encrypted values are there
     * @param {?=} key  generatedKey() or user defined key - to decrypt encrypted values
     * @return {?} cookies - all the cookies  stored
     */
    NgxEncryptCookieService.prototype.getAll = /**
     * @param {?=} encrypted boolean - to know encrypted values are there
     * @param {?=} key  generatedKey() or user defined key - to decrypt encrypted values
     * @return {?} cookies - all the cookies  stored
     */
    function (encrypted, key) {
        var _this = this;
        if (!this.documentIsAccessible) {
            return {};
        }
        /** @type {?} */
        var cookies = {};
        if (encrypted) {
            if (document.cookie && document.cookie !== '') {
                document.cookie.split(';').forEach((/**
                 * @param {?} currentCookie
                 * @return {?}
                 */
                function (currentCookie) {
                    var _a = tslib_1.__read(currentCookie.split('='), 2), cookieName = _a[0], cookieValue = _a[1];
                    /** @type {?} */
                    var cookie_name = _this.safeDecodeURIComponent(cookieName.replace(/^ /, ''));
                    /** @type {?} */
                    var cookie_val = _this.get(cookie_name, encrypted, key);
                    cookies[_this.safeDecodeURIComponent(cookieName.replace(/^ /, ''))] = cookie_val;
                    // cookies[]
                }));
            }
        }
        else {
            if (document.cookie && document.cookie !== '') {
                document.cookie.split(';').forEach((/**
                 * @param {?} currentCookie
                 * @return {?}
                 */
                function (currentCookie) {
                    var _a = tslib_1.__read(currentCookie.split('='), 2), cookieName = _a[0], cookieValue = _a[1];
                    /** @type {?} */
                    var cookie_name = _this.safeDecodeURIComponent(cookieName.replace(/^ /, ''));
                    cookies[_this.safeDecodeURIComponent(cookieName.replace(/^ /, ''))] = _this.safeDecodeURIComponent(cookieValue);
                    // cookies[]
                }));
            }
        }
        return cookies;
    };
    /**
     * @private
     * @return {?}
     */
    NgxEncryptCookieService.prototype.getAllCookies = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.documentIsAccessible) {
            return {};
        }
        /** @type {?} */
        var cookies = {};
        if (document.cookie && document.cookie !== '') {
            document.cookie.split(';').forEach((/**
             * @param {?} currentCookie
             * @return {?}
             */
            function (currentCookie) {
                var _a = tslib_1.__read(currentCookie.split('='), 2), cookieName = _a[0], cookieValue = _a[1];
                /** @type {?} */
                var cookie_name = _this.safeDecodeURIComponent(cookieName.replace(/^ /, ''));
                cookies[_this.safeDecodeURIComponent(cookieName.replace(/^ /, ''))] = _this.safeDecodeURIComponent(cookieValue);
                // cookies[]
            }));
        }
        return cookies;
    };
    /**
     * @param name     Cookie name
     * @param value    Cookie value
     * @param encrypt  boolean - to encrypt cookie value or not
     * @param key      a key can either generate using generateKey() or user defined key
     * @param expires  Number of days until the cookies expires or an actual `Date`
     * @param path     Cookie path (eg:"/")
     * @param domain   Cookie domain (eg:"domain.com")
     * @param secure   Secure flag
     * @param sameSite OWASP samesite token `Lax`, `None`, or `Strict`. Defaults to `Lax`
     */
    /**
     * @param {?} name     Cookie name
     * @param {?} value    Cookie value
     * @param {?} encrypt  boolean - to encrypt cookie value or not
     * @param {?=} key      a key can either generate using generateKey() or user defined key
     * @param {?=} expires  Number of days until the cookies expires or an actual `Date`
     * @param {?=} path     Cookie path (eg:"/")
     * @param {?=} domain   Cookie domain (eg:"domain.com")
     * @param {?=} secure   Secure flag
     * @param {?=} sameSite OWASP samesite token `Lax`, `None`, or `Strict`. Defaults to `Lax`
     * @return {?}
     */
    NgxEncryptCookieService.prototype.set = /**
     * @param {?} name     Cookie name
     * @param {?} value    Cookie value
     * @param {?} encrypt  boolean - to encrypt cookie value or not
     * @param {?=} key      a key can either generate using generateKey() or user defined key
     * @param {?=} expires  Number of days until the cookies expires or an actual `Date`
     * @param {?=} path     Cookie path (eg:"/")
     * @param {?=} domain   Cookie domain (eg:"domain.com")
     * @param {?=} secure   Secure flag
     * @param {?=} sameSite OWASP samesite token `Lax`, `None`, or `Strict`. Defaults to `Lax`
     * @return {?}
     */
    function (name, value, encrypt, key, expires, path, domain, secure, sameSite) {
        if (sameSite === void 0) { sameSite = 'Lax'; }
        /** @type {?} */
        var cookieString;
        if (!this.documentIsAccessible) {
            return;
        }
        if (encrypt) {
            if (key) {
                /** @type {?} */
                var encrypted_msg = this.encrypt(value, key);
                cookieString = encodeURIComponent(name) + '=' + encodeURIComponent(encrypted_msg) + ';';
            }
            else {
                console.error("pass key to encrypt cookie value");
                return "key fail";
            }
        }
        else {
            cookieString = encodeURIComponent(name) + '=' + encodeURIComponent(value) + ';';
        }
        if (expires) {
            if (typeof expires === 'number') {
                /** @type {?} */
                var dateExpires = new Date(new Date().getTime() + expires * 1000 * 60 * 60 * 24);
                cookieString += 'expires=' + dateExpires.toUTCString() + ';';
            }
            else {
                cookieString += 'expires=' + expires.toUTCString() + ';';
            }
        }
        if (path) {
            cookieString += 'path=' + path + ';';
        }
        if (domain) {
            cookieString += 'domain=' + domain + ';';
        }
        if (secure === false && sameSite === 'None') {
            secure = true;
            console.warn("[ngx-secure-cookies] Cookie " + name + " was forced with secure flag because sameSite=None.");
        }
        if (secure) {
            cookieString += 'secure;';
        }
        cookieString += 'sameSite=' + sameSite + ';';
        document.cookie = cookieString;
        return true;
    };
    /**
     * @param name   Cookie name
     * @param path   Cookie path
     * @param domain Cookie domain
     */
    /**
     * @param {?} name   Cookie name
     * @param {?=} path   Cookie path
     * @param {?=} domain Cookie domain
     * @param {?=} secure
     * @param {?=} sameSite
     * @return {?}
     */
    NgxEncryptCookieService.prototype.delete = /**
     * @param {?} name   Cookie name
     * @param {?=} path   Cookie path
     * @param {?=} domain Cookie domain
     * @param {?=} secure
     * @param {?=} sameSite
     * @return {?}
     */
    function (name, path, domain, secure, sameSite) {
        if (sameSite === void 0) { sameSite = 'Lax'; }
        if (!this.documentIsAccessible) {
            return;
        }
        this.set(name, '', false, "", new Date('Thu, 01 Jan 1970 00:00:01 GMT'), path, domain, secure, sameSite);
    };
    /**
     * @param path   Cookie path
     * @param domain Cookie domain
     */
    /**
     * @param {?=} path   Cookie path
     * @param {?=} domain Cookie domain
     * @param {?=} secure
     * @param {?=} sameSite
     * @return {?}
     */
    NgxEncryptCookieService.prototype.deleteAll = /**
     * @param {?=} path   Cookie path
     * @param {?=} domain Cookie domain
     * @param {?=} secure
     * @param {?=} sameSite
     * @return {?}
     */
    function (path, domain, secure, sameSite) {
        if (sameSite === void 0) { sameSite = 'Lax'; }
        if (!this.documentIsAccessible) {
            return;
        }
        /** @type {?} */
        var cookies = this.getAllCookies();
        for (var cookieName in cookies) {
            if (cookies.hasOwnProperty(cookieName)) {
                this.delete(cookieName, path, domain, secure, sameSite);
            }
        }
    };
    /**
     * @param name Cookie name
     * @returns property RegExp
     */
    /**
     * @private
     * @param {?} name Cookie name
     * @return {?} property RegExp
     */
    NgxEncryptCookieService.prototype.getCookieRegExp = /**
     * @private
     * @param {?} name Cookie name
     * @return {?} property RegExp
     */
    function (name) {
        /** @type {?} */
        var escapedName = name.replace(/([\[\]\{\}\(\)\|\=\;\+\?\,\.\*\^\$])/gi, '\\$1');
        return new RegExp('(?:^' + escapedName + '|;\\s*' + escapedName + ')=(.*?)(?:;|$)', 'g');
    };
    /**
     * @private
     * @param {?} encodedURIComponent
     * @return {?}
     */
    NgxEncryptCookieService.prototype.safeDecodeURIComponent = /**
     * @private
     * @param {?} encodedURIComponent
     * @return {?}
     */
    function (encodedURIComponent) {
        try {
            return decodeURIComponent(encodedURIComponent);
        }
        catch (_a) {
            return encodedURIComponent;
        }
    };
    NgxEncryptCookieService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    NgxEncryptCookieService.ctorParameters = function () { return [
        { type: InjectionToken, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    /** @nocollapse */ NgxEncryptCookieService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NgxEncryptCookieService_Factory() { return new NgxEncryptCookieService(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: NgxEncryptCookieService, providedIn: "root" });
    return NgxEncryptCookieService;
}());
export { NgxEncryptCookieService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxEncryptCookieService.prototype.documentIsAccessible;
    /**
     * @type {?}
     * @private
     */
    NgxEncryptCookieService.prototype.platformId;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWVuY3J5cHQtY29va2llLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZW5jcnlwdC1jb29raWUvIiwic291cmNlcyI6WyJsaWIvbmd4LWVuY3J5cHQtY29va2llLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEtBQUssUUFBUSxNQUFNLFdBQVcsQ0FBQzs7QUFFdEM7SUFNRSxpQ0FFK0IsVUFBa0M7UUFBbEMsZUFBVSxHQUFWLFVBQVUsQ0FBd0I7UUFHL0QsSUFBSSxDQUFDLG9CQUFvQixHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBSUQ7Ozs7O09BS0c7Ozs7Ozs7SUFDSCw2Q0FBVzs7Ozs7O0lBQVgsVUFBWSxPQUFnQixFQUFFLFVBQW1COztZQUUzQyxJQUFJLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7O1lBQzdDLFlBQVk7O1lBQ1osZ0JBQWdCO1FBRXBCLE9BQU8sQ0FBQyxDQUFDLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQztRQUMzRCxVQUFVLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUM7UUFFcEYsUUFBUSxZQUFZLEVBQUU7WUFDcEIsS0FBSyxRQUFROztvQkFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsRUFBRSxPQUFPLEVBQUUsR0FBRyxHQUFHLEVBQUUsRUFB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Y0FBYyx1QkFZbkQsTUFBTSxTQUFDLFdBQVc7OztrQ0FadkI7Q0FnVkMsQUE1VUQsSUE0VUM7U0F6VVksdUJBQXVCOzs7Ozs7SUFDbEMsdURBQStDOzs7OztJQUk3Qyw2Q0FBK0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIFBMQVRGT1JNX0lELCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCAqIGFzIENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4RW5jcnlwdENvb2tpZVNlcnZpY2Uge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZG9jdW1lbnRJc0FjY2Vzc2libGU6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG5cclxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogSW5qZWN0aW9uVG9rZW48b2JqZWN0PlxyXG4gICkge1xyXG5cclxuICAgIHRoaXMuZG9jdW1lbnRJc0FjY2Vzc2libGUgPSBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpO1xyXG4gIH1cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ga2V5U2l6ZSBDb29raWUgbmFtZVxyXG4gICAqIEBwYXJhbSBwYXNzUGhyYXNlIHNlY3JldCBwYXNzUGhyYXNlIFxyXG4gICAqIEByZXR1cm5zIHJldHVybnMga2V5IHdoZW4gc2V0dGluZyBjb29raWUgYW5kIGdldHRpbmcgY29va2llXHJcbiAgICogZGVmYXVsdCBrZXlTaXplIGlzIDEyOC8zMiBhbmQgZGVmYXVsdCBwYXNzUGhyYXNlIGlzIFwiU2VjcmV0IFBhc3NQaHJhc2VcIlxyXG4gICAqL1xyXG4gIGdlbmVyYXRlS2V5KGtleVNpemU/OiBzdHJpbmcsIHBhc3NQaHJhc2U/OiBzdHJpbmcpIHtcclxuXHJcbiAgICB2YXIgc2FsdCA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDEyOCAvIDgpO1xyXG4gICAgdmFyIGtleVNpemVCeXRlcztcclxuICAgIHZhciBzZWNydGVQYXNzUGhyYXNlO1xyXG5cclxuICAgIGtleVNpemUgPyBrZXlTaXplQnl0ZXMgPSBrZXlTaXplIDoga2V5U2l6ZUJ5dGVzID0gXCIxMjgvMzJcIjtcclxuICAgIHBhc3NQaHJhc2UgPyBzZWNydGVQYXNzUGhyYXNlID0gcGFzc1BocmFzZSA6IHNlY3J0ZVBhc3NQaHJhc2UgPSBcIlNlY3JldCBQYXNzUGhyYXNlXCI7XHJcblxyXG4gICAgc3dpdGNoIChrZXlTaXplQnl0ZXMpIHtcclxuICAgICAgY2FzZSBcIjEyOC8zMlwiOiB2YXIgbXNnID0gQ3J5cHRvSlMuUEJLREYyKHNlY3J0ZVBhc3NQaHJhc2UsIHNhbHQsIHsga2V5U2l6ZTogMTI4IC8gMzIgfSlcclxuICAgICAgICByZXR1cm4gbXNnLnRvU3RyaW5nKClcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIjI1Ni8zMlwiOiB2YXIgbXNnID0gQ3J5cHRvSlMuUEJLREYyKHNlY3J0ZVBhc3NQaHJhc2UsIHNhbHQsIHsga2V5U2l6ZTogMjU2IC8gMzIgfSlcclxuICAgICAgICByZXR1cm4gbXNnLnRvU3RyaW5nKClcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIjUxMi8zMlwiOiB2YXIgbXNnID0gQ3J5cHRvSlMuUEJLREYyKHNlY3J0ZVBhc3NQaHJhc2UsIHNhbHQsIHsga2V5U2l6ZTogNTEyIC8gMzIgfSlcclxuICAgICAgICByZXR1cm4gbXNnLnRvU3RyaW5nKClcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKiogXHJcbiAgICogZW5jcnlwdCgpIGlzIGNhbGxpbmcgd2hlbiBzZXQoKSBjYWxsc1xyXG4gICAqIEBwYXJhbSB2YWwgdmFsdWUgdG8gc3RvcmUgaW4gY29va2llc1xyXG4gICAqIEBwYXJhbSBzZWNyZXRfa2V5IGlzIGEga2V5IGdlbmVyYXRlZCBieSB1c2luZyBnZW5lcmF0ZUtleSgpIG9yIHVzZXIgZGVmaW5lZCBrZXkuXHJcbiAgICogQHJldHVybnMgZW5jcnlwdGVkIHZhbCB0byBzZXQoKSBhbmQgdGhlcmUgdGhlIGNvb2tpZSB3aWxsIHNldC4gaWYgdXNlciBkb2VzbnQgZ2VuZXJhdGVLZXkgb3IgcGFzcyBrZXkgZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgKi9cclxuICBwcml2YXRlIGVuY3J5cHQodmFsOiBTdHJpbmcsIHNlY3JldF9rZXk6IFN0cmluZykge1xyXG5cclxuICAgIGlmIChzZWNyZXRfa2V5ICE9IG51bGwgfHwgc2VjcmV0X2tleSAhPSBcIlwiIHx8IHNlY3JldF9rZXkubGVuZ3RoID4gMCkge1xyXG4gICAgICB2YXIgZW5jcnlwdF9tc2cgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdCh2YWwsIHNlY3JldF9rZXkpO1xyXG4gICAgICByZXR1cm4gZW5jcnlwdF9tc2c7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlBhc3MgU2VjcmV0IGtleSB0byBzZXQgY29va2llXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBcclxuICAgKiBAcGFyYW0gY29va2llX25hbWUgY29va2llIG5hbWUgd2hpY2ggaXMgc3RvcmVkXHJcbiAgICogQHBhcmFtIGVuY3J5cHRlZCBib29sZWFuIC0gY29va2llIHN0b3JlZCBoYXZpbmcgZW5jcnlwdGVkIHZhbCBvciBub3RcclxuICAgKiBAcGFyYW0gc2VjcmV0X2tleSBpcyBrZXkgd2hpY2ggaXMgdXNlZCB0byBlbmNyeXB0IGNvb2tpZSB2YWwuIGl0IGlzIG5vdCByZXF1aXJlZCBpZiBlbmNyeXB0ZWQgaXMgZmFsc2VcclxuICAgKi9cclxuICBwcml2YXRlIGRlY3J5cHQoY29va2llTmFtZTogc3RyaW5nLCBlbmNyeXB0ZWQ6IGJvb2xlYW4sIHNlY3JldF9rZXk/OiBTdHJpbmcsICkge1xyXG4gICAgaWYgKHRoaXMuZG9jdW1lbnRJc0FjY2Vzc2libGUgJiYgdGhpcy5jaGVjayhjb29raWVOYW1lKSkge1xyXG4gICAgICBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGNvb2tpZU5hbWUpO1xyXG5cclxuICAgICAgY29uc3QgcmVnRXhwOiBSZWdFeHAgPSB0aGlzLmdldENvb2tpZVJlZ0V4cChjb29raWVOYW1lKTtcclxuICAgICAgY29uc3QgcmVzdWx0OiBSZWdFeHBFeGVjQXJyYXkgPSByZWdFeHAuZXhlYyhkb2N1bWVudC5jb29raWUpO1xyXG5cclxuICAgICAgaWYgKGVuY3J5cHRlZCkge1xyXG4gICAgICAgIGlmIChzZWNyZXRfa2V5KSB7XHJcblxyXG4gICAgICAgICAgbGV0IGVuY3J5cHRfbXNnID0gdGhpcy5zYWZlRGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdFsxXSk7XHJcbiAgICAgICAgICBsZXQgZGVjcnlwdF9tc2cgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChlbmNyeXB0X21zZywgc2VjcmV0X2tleSk7XHJcbiAgICAgICAgICBsZXQgbWVzc2FnZSA9IGRlY3J5cHRfbXNnLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcclxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwicGFzcyBzZWNyZXQga2V5IHRvIGdldCBjb29raWUgdmFsdWVcIilcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZURlY29kZVVSSUNvbXBvbmVudChyZXN1bHRbMV0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIGNvb2tpZU5hbWUgQ29va2llIG5hbWVcclxuICAgKiBAcmV0dXJucyBib29sZWFuICB3aGV0aGVyIGNvb2tpZSB3aXRoIHNwZWNpZmllZCBuYW1lIGlzIGV4aXN0ZWQgb3Igbm90XHJcbiAgICovXHJcbiAgY2hlY2soY29va2llTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRJc0FjY2Vzc2libGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGNvb2tpZU5hbWUpO1xyXG5cclxuICAgIGNvbnN0IHJlZ0V4cDogUmVnRXhwID0gdGhpcy5nZXRDb29raWVSZWdFeHAobmFtZSk7XHJcbiAgICBjb25zdCBleGlzdHM6IGJvb2xlYW4gPSByZWdFeHAudGVzdChkb2N1bWVudC5jb29raWUpO1xyXG5cclxuICAgIHJldHVybiBleGlzdHM7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogXHJcbiAgICogQHBhcmFtIGNvb2tpZU5hbWUgY29va2llIG5hbWVcclxuICAgKiBAcGFyYW0gZW5jcnlwdGlvbiBib29sZWFuIC0gd2hldGhlciB0byB3YW50IGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQgdmFsdWUuIFxyXG4gICAqIEBwYXJhbSBrZXkgLSBpdCBzaG91bGQgZW50ZXIgaWYgZW5jcnlwdGVkPXRydWUgb3RoZXJ3aXNlIGVycm9yIHdpbGwgYmUgdGhyb3duLmtleSBjYW4gYmUgZWl0aGVyIGdlbmVyYXRlZCB1c2luZyBnZW5lcmF0ZUtleSgpIG9yXHJcbiAgICAgICAgICAgICAgICAgICB1c2VyIGRlZmluZGVkIGtleVxyXG4gICAqL1xyXG4gIGdldChjb29raWVOYW1lOiBzdHJpbmcsIGVuY3J5cHRpb246IGJvb2xlYW4sIGtleT86IHN0cmluZywgKTogc3RyaW5nIHtcclxuICAgIHZhciB2YWw6c3RyaW5nO1xyXG4gICAgIGlmKGVuY3J5cHRpb24pe1xyXG4gICAgICAgaWYoa2V5KXtcclxuICAgICAgICB2YWwgPSB0aGlzLmRlY3J5cHQoY29va2llTmFtZSwgZW5jcnlwdGlvbiwga2V5KTtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYga2V5IGlzIG5vdCBwYXNzZWQgb3IgZW5jcnlwdGVkID0gZmFsc2U7XHJcbiAgICB2YWwgPSB0aGlzLmRlY3J5cHQoY29va2llTmFtZSxmYWxzZSxudWxsKTtcclxuICAgIHJldHVybiB2YWw7XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgYm9vbGVhbiAtIHRvIGtub3cgZW5jcnlwdGVkIHZhbHVlcyBhcmUgdGhlcmVcclxuICAgKiBAcGFyYW0ga2V5ICBnZW5lcmF0ZWRLZXkoKSBvciB1c2VyIGRlZmluZWQga2V5IC0gdG8gZGVjcnlwdCBlbmNyeXB0ZWQgdmFsdWVzXHJcbiAgICogQHJldHVybnMgY29va2llcyAtIGFsbCB0aGUgY29va2llcyAgc3RvcmVkXHJcbiAgICovXHJcbiAgZ2V0QWxsKGVuY3J5cHRlZD86IGJvb2xlYW4sIGtleT86IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xyXG4gICAgaWYgKCF0aGlzLmRvY3VtZW50SXNBY2Nlc3NpYmxlKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvb2tpZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcclxuXHJcbiAgICBpZiAoZW5jcnlwdGVkKSB7XHJcbiAgICAgIGlmIChkb2N1bWVudC5jb29raWUgJiYgZG9jdW1lbnQuY29va2llICE9PSAnJykge1xyXG5cclxuICAgICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5mb3JFYWNoKChjdXJyZW50Q29va2llKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBbY29va2llTmFtZSwgY29va2llVmFsdWVdID0gY3VycmVudENvb2tpZS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgdmFyIGNvb2tpZV9uYW1lID0gdGhpcy5zYWZlRGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZU5hbWUucmVwbGFjZSgvXiAvLCAnJykpO1xyXG4gICAgICAgICAgdmFyIGNvb2tpZV92YWwgPSB0aGlzLmdldChjb29raWVfbmFtZSwgZW5jcnlwdGVkLCBrZXkpXHJcbiAgICAgICAgICBjb29raWVzW3RoaXMuc2FmZURlY29kZVVSSUNvbXBvbmVudChjb29raWVOYW1lLnJlcGxhY2UoL14gLywgJycpKV0gPSBjb29raWVfdmFsXHJcbiAgICAgICAgICAvLyBjb29raWVzW11cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChkb2N1bWVudC5jb29raWUgJiYgZG9jdW1lbnQuY29va2llICE9PSAnJykge1xyXG5cclxuICAgICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5mb3JFYWNoKChjdXJyZW50Q29va2llKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBbY29va2llTmFtZSwgY29va2llVmFsdWVdID0gY3VycmVudENvb2tpZS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgdmFyIGNvb2tpZV9uYW1lID0gdGhpcy5zYWZlRGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZU5hbWUucmVwbGFjZSgvXiAvLCAnJykpO1xyXG4gICAgICAgICAgY29va2llc1t0aGlzLnNhZmVEZWNvZGVVUklDb21wb25lbnQoY29va2llTmFtZS5yZXBsYWNlKC9eIC8sICcnKSldID0gdGhpcy5zYWZlRGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVZhbHVlKVxyXG4gICAgICAgICAgLy8gY29va2llc1tdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29va2llc1xyXG4gIH1cclxuXHJcblxyXG4gIHByaXZhdGUgZ2V0QWxsQ29va2llcygpIHtcclxuICAgIGlmICghdGhpcy5kb2N1bWVudElzQWNjZXNzaWJsZSkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb29raWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LmNvb2tpZSAmJiBkb2N1bWVudC5jb29raWUgIT09ICcnKSB7XHJcblxyXG4gICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5mb3JFYWNoKChjdXJyZW50Q29va2llKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW2Nvb2tpZU5hbWUsIGNvb2tpZVZhbHVlXSA9IGN1cnJlbnRDb29raWUuc3BsaXQoJz0nKTtcclxuICAgICAgICB2YXIgY29va2llX25hbWUgPSB0aGlzLnNhZmVEZWNvZGVVUklDb21wb25lbnQoY29va2llTmFtZS5yZXBsYWNlKC9eIC8sICcnKSk7XHJcbiAgICAgICAgY29va2llc1t0aGlzLnNhZmVEZWNvZGVVUklDb21wb25lbnQoY29va2llTmFtZS5yZXBsYWNlKC9eIC8sICcnKSldID0gdGhpcy5zYWZlRGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVZhbHVlKVxyXG4gICAgICAgIC8vIGNvb2tpZXNbXVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29va2llc1xyXG4gIH1cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gbmFtZSAgICAgQ29va2llIG5hbWVcclxuICAgKiBAcGFyYW0gdmFsdWUgICAgQ29va2llIHZhbHVlXHJcbiAgICogQHBhcmFtIGVuY3J5cHQgIGJvb2xlYW4gLSB0byBlbmNyeXB0IGNvb2tpZSB2YWx1ZSBvciBub3RcclxuICAgKiBAcGFyYW0ga2V5ICAgICAgYSBrZXkgY2FuIGVpdGhlciBnZW5lcmF0ZSB1c2luZyBnZW5lcmF0ZUtleSgpIG9yIHVzZXIgZGVmaW5lZCBrZXkgXHJcbiAgICogQHBhcmFtIGV4cGlyZXMgIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBjb29raWVzIGV4cGlyZXMgb3IgYW4gYWN0dWFsIGBEYXRlYFxyXG4gICAqIEBwYXJhbSBwYXRoICAgICBDb29raWUgcGF0aCAoZWc6XCIvXCIpXHJcbiAgICogQHBhcmFtIGRvbWFpbiAgIENvb2tpZSBkb21haW4gKGVnOlwiZG9tYWluLmNvbVwiKVxyXG4gICAqIEBwYXJhbSBzZWN1cmUgICBTZWN1cmUgZmxhZ1xyXG4gICAqIEBwYXJhbSBzYW1lU2l0ZSBPV0FTUCBzYW1lc2l0ZSB0b2tlbiBgTGF4YCwgYE5vbmVgLCBvciBgU3RyaWN0YC4gRGVmYXVsdHMgdG8gYExheGBcclxuICAgKi9cclxuICBzZXQoXHJcbiAgICBuYW1lOiBzdHJpbmcsXHJcbiAgICB2YWx1ZTogc3RyaW5nLFxyXG4gICAgZW5jcnlwdDogYm9vbGVhbixcclxuICAgIGtleT86IHN0cmluZyxcclxuICAgIGV4cGlyZXM/OiBudW1iZXIgfCBEYXRlLFxyXG4gICAgcGF0aD86IHN0cmluZyxcclxuICAgIGRvbWFpbj86IHN0cmluZyxcclxuICAgIHNlY3VyZT86IGJvb2xlYW4sXHJcbiAgICBzYW1lU2l0ZTogJ0xheCcgfCAnTm9uZScgfCAnU3RyaWN0JyA9ICdMYXgnXHJcbiAgKTogYW55IHtcclxuICAgIHZhciBjb29raWVTdHJpbmc6IHN0cmluZztcclxuXHJcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRJc0FjY2Vzc2libGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmNyeXB0KSB7XHJcbiAgICAgaWYoa2V5KXtcclxuICAgICAgbGV0IGVuY3J5cHRlZF9tc2cgPSB0aGlzLmVuY3J5cHQodmFsdWUsIGtleSlcclxuICAgICAgY29va2llU3RyaW5nID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGVuY3J5cHRlZF9tc2cpICsgJzsnO1xyXG4gICAgIH1cclxuICAgICBlbHNle1xyXG4gICAgICAgY29uc29sZS5lcnJvcihcInBhc3Mga2V5IHRvIGVuY3J5cHQgY29va2llIHZhbHVlXCIpO1xyXG4gICAgICAgcmV0dXJuIFwia2V5IGZhaWxcIjtcclxuICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29va2llU3RyaW5nID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArICc7JztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXhwaXJlcykge1xyXG4gICAgICBpZiAodHlwZW9mIGV4cGlyZXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZUV4cGlyZXM6IERhdGUgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGV4cGlyZXMgKiAxMDAwICogNjAgKiA2MCAqIDI0KTtcclxuXHJcbiAgICAgICAgY29va2llU3RyaW5nICs9ICdleHBpcmVzPScgKyBkYXRlRXhwaXJlcy50b1VUQ1N0cmluZygpICsgJzsnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvb2tpZVN0cmluZyArPSAnZXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpICsgJzsnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhdGgpIHtcclxuICAgICAgY29va2llU3RyaW5nICs9ICdwYXRoPScgKyBwYXRoICsgJzsnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkb21haW4pIHtcclxuICAgICAgY29va2llU3RyaW5nICs9ICdkb21haW49JyArIGRvbWFpbiArICc7JztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VjdXJlID09PSBmYWxzZSAmJiBzYW1lU2l0ZSA9PT0gJ05vbmUnKSB7XHJcbiAgICAgIHNlY3VyZSA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgW25neC1zZWN1cmUtY29va2llc10gQ29va2llICR7bmFtZX0gd2FzIGZvcmNlZCB3aXRoIHNlY3VyZSBmbGFnIGJlY2F1c2Ugc2FtZVNpdGU9Tm9uZS5gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VjdXJlKSB7XHJcbiAgICAgIGNvb2tpZVN0cmluZyArPSAnc2VjdXJlOyc7XHJcbiAgICB9XHJcblxyXG4gICAgY29va2llU3RyaW5nICs9ICdzYW1lU2l0ZT0nICsgc2FtZVNpdGUgKyAnOyc7XHJcblxyXG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3RyaW5nO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gbmFtZSAgIENvb2tpZSBuYW1lXHJcbiAgICogQHBhcmFtIHBhdGggICBDb29raWUgcGF0aFxyXG4gICAqIEBwYXJhbSBkb21haW4gQ29va2llIGRvbWFpblxyXG4gICAqL1xyXG5cclxuICBkZWxldGUobmFtZTogc3RyaW5nLCBwYXRoPzogc3RyaW5nLCBkb21haW4/OiBzdHJpbmcsIHNlY3VyZT86IGJvb2xlYW4sIHNhbWVTaXRlOiAnTGF4JyB8ICdOb25lJyB8ICdTdHJpY3QnID0gJ0xheCcpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5kb2N1bWVudElzQWNjZXNzaWJsZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXQobmFtZSwgJycsIGZhbHNlLCBcIlwiLCBuZXcgRGF0ZSgnVGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMSBHTVQnKSwgcGF0aCwgZG9tYWluLCBzZWN1cmUsIHNhbWVTaXRlKTtcclxuICB9XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBwYXRoICAgQ29va2llIHBhdGhcclxuICAgKiBAcGFyYW0gZG9tYWluIENvb2tpZSBkb21haW5cclxuICAgKi9cclxuICBkZWxldGVBbGwocGF0aD86IHN0cmluZywgZG9tYWluPzogc3RyaW5nLCBzZWN1cmU/OiBib29sZWFuLCBzYW1lU2l0ZTogJ0xheCcgfCAnTm9uZScgfCAnU3RyaWN0JyA9ICdMYXgnKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRJc0FjY2Vzc2libGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvb2tpZXM6IGFueSA9IHRoaXMuZ2V0QWxsQ29va2llcygpO1xyXG5cclxuICAgIGZvciAoY29uc3QgY29va2llTmFtZSBpbiBjb29raWVzKSB7XHJcbiAgICAgIGlmIChjb29raWVzLmhhc093blByb3BlcnR5KGNvb2tpZU5hbWUpKSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGUoY29va2llTmFtZSwgcGF0aCwgZG9tYWluLCBzZWN1cmUsIHNhbWVTaXRlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBuYW1lIENvb2tpZSBuYW1lXHJcbiAgICogQHJldHVybnMgcHJvcGVydHkgUmVnRXhwXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRDb29raWVSZWdFeHAobmFtZTogc3RyaW5nKTogUmVnRXhwIHtcclxuICAgIGNvbnN0IGVzY2FwZWROYW1lOiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoLyhbXFxbXFxdXFx7XFx9XFwoXFwpXFx8XFw9XFw7XFwrXFw/XFwsXFwuXFwqXFxeXFwkXSkvZ2ksICdcXFxcJDEnKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XicgKyBlc2NhcGVkTmFtZSArICd8O1xcXFxzKicgKyBlc2NhcGVkTmFtZSArICcpPSguKj8pKD86O3wkKScsICdnJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNhZmVEZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVSSUNvbXBvbmVudDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVSSUNvbXBvbmVudCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGVuY29kZWRVUklDb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==